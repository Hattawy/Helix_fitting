#include <time.h>
#define TRUE 1
#define FALSE 0
#define GEMDEBUG FALSE
#define LINLMAX  1400 /* maximum number characters per input line */
#define NS_PER_TIC_FIT 100 /* nanoseconds per ALTRO sample */
#define DAQ_CONVERT 100 /* int number to convert TDC values to clock tics*/
#define NAL_CHAN 3200 /* Number of channels of ALTRO data */
#define NUM_PADS 3200 /* Number of actual pads in the RTPC */
#define NAL_SAMP 100 /* Number of time samples from ALTRO */
#define NAL_KEEP NAL_SAMP /* highest  time bin to record*/
#define TPC_TZERO 15 /* trigger time in TPC */
#define TPC_TGEM 16 //13.499 //11.765 /* altro time for signals arising from hits at GEM surface*/
#define TPC_TCAT 65 /* altro time for signals arising from hits at cathode surface  -- but note this is not a well-defined value*/
#define TPC_TMIN 5 /* earliest TPC track data to keep */
#define TPC_TMAX 75 /* latest TPC track data to keep */ 
#define SMIN 15.0  /* what a hit's radius gets set to if it is late */ 
#define SMAX 75.0  /* what a hit's radius gets set to if it is early */
#define DPHI_AT_SMIN 0.900 /* default delta-phi for hits placed at SMIN */

/* The status bits for hits in the hitlists */
#define HUNTCHD 0  /* - untouched - no status set yet */
#define HISUSED 1  /* - (was 1) used */
#define HREMOVD 2  /* - (was 2)removed for high residual to helix */
#define HDISEAR 4  /* - t<TPC_TMIN */
#define HDISLAT 8  /* - t>TPC_TMAX */
#define HEARLST 0x10  /* - this hit is has earliest time for this pad on this chain */
#define HABSORB 0x20  /* - hit absorbed in routine weightData */
#define HSMALLQ 0x40  /* - (was -3) charge < THR_Q_LINK */
#define HITTEMP 0x80  /* for routine-specific status marks. */
#define FAKE_HIT 0x100 /* any type of artificially-generated hit */
#define PROJECTED_HIT 0x200 /* indicates a hit generated by projecting fitted track */
#define SWUMHIT 0x400 /* indicates a hit generated by swimming the track */
#define HBADPAD 0x800 /* hit is on a pad marked as bad */
#define HTRUNCA 0x1000 /* hit is used in ADC-truncation */ 
#define HTRUNCL 0x2000 /* hit is used in ADC-truncation */ 
#define HTRUNCAL 0x4000 /* hit is used in ADC+PATHLENGTH=truncation */
#define HITUNAV (HISUSED|HDISEAR|HDISLAT|HABSORB|HSMALLQ|FAKE_HIT|HBADPAD) /* reasons to NOT use a hit in the chain-linker */

#define HITTHR 30 //Max nb of hit on a single pad in a single event
#define RESCUT 5 //throw away data w/ res over this number
#define THRESHA 0 //threshold that determines which data from the altro are put into the raw data to fit array
#define THR_Q_LINK 2 // (not used) minimum pulse height for possible inclusion in a chain
#define PI    3.141592654
#define TWOPI 6.283185308
#define PIBY2 1.570796327
#define PAD_RAD 69.0 //this is the radius where the pad plane is located (in mm)
#define GEM_RAD 60.0 //this is the radius where the first GEM plane is located (in mm)
#define CAT_RAD 30.0 //radius of cathode (mm)
#define WIN_RAD 20.0 //radius of window (mm)
#define ZEND 100.0 // half-length of rtpc volume (mm)
#define XCAGE 5.182 // location of the chord-wall active surface (in mm)
#define XBONE 3.581 // location of the surface of the backbone plate (mm)
#define FBANG 74.0*PI/180.0 /* half-angle of phi acceptance of rtpc: 74 degrees */
#define DEL_Z 5.0 //a single pad length in z (mm)
#define DEL_A 4.45  //the phi dimension of a pad (the arc length) (mm)
#define QPERMM 100.0 // nominal signal charge (adc counts) per mm of track length for projected tracks

/* Info from Surveyors .. location of BoNuC RTPC center in CLAS coordinates */
/*   These numbers are from survey. */
#define ZBONUS -640. 
/* during fitting process, set these vales in init_globals.c */
#define XBONUS 0.0
#define YBONUS 0.0

/* DVCS Solenoid location from Surveyors .. in CLAS coordinates. Note that x,y are
   reported relative to the ideal beamline. For now I assume that values reported
   by CLAS analysis are relative to this same line. */
#define ZSOL -640.
#define XSOL    0.
#define YSOL    0.

//the angular coverage of a single pad (rad)
#define DEL_PHI (DEL_A/PAD_RAD) //the angular coverage of a single pad (rad)
#define NUM_XTRA    (NAL_CHAN-NUM_PADS)
#define EVT_TRKS 50 // maximum # of allowed tracks in GCPB bank
#define MAX_NUM_CHAINS 100
#define MAX_HITS_ON_CHAIN 300
// #define HH_MAX_NUM_HITS 2000 /* the raw hit structure has this much space */
//#define HH_MAX_NUM_HITS 3000 /* the raw hit structure has this much space */
#define HH_MAX_NUM_HITS 6000 /* the raw hit structure has this much space */
#define MIN_LINKS_ON_TRACK 10 //default = 15 /* at least this many links to try a track */
#define MAX_LINK_SEP 10.5 //default = 9.0  /* hits must be this close to be together on a chain (mm)*/
#define WW_PHI_CUT 0.07 //if a given data point is within this phi range of another link
#define WW_RAD_CUT 0.5  //and within this r range, it will be combined
#define WW_Z_CUT 7.1  //and within this z range, it will be combined
#define DCA_CUT 20    //a track must come within this close to the beam line to refit including
                      //the beamline 
#define HH_MAX_NUM_XTRS 200 /* the raw xtra structure has this much space */

//these are for the B-Field Map, a really dumb way to do this
#define NUM_Z1 21
#define NUM_S1 15
#define NUM_VAL1 315

#define CL2BM 0
#define CL2BO 1
#define CL2SO 2
#define BM2CL 3
#define BO2CL 4
#define SO2CL 5
#define BM2BO 6
#define BM2SO 7
#define BO2BM 8
#define BO2SO 9
#define SO2BM 10
#define SO2BO 11

#define MAX_ERRORS 100
#define SIGMA_R 0.53 // (mm) observed resolution in 'r' for points fitted to helix
#define SIGMA_PHI 0.025 // (radians) observed resolution in 'phi' for points fitted to helix
#define SIGMA_Z 1.2 // (mm) observed resolution in 'z' for points fitted to helix 

// #define M_PRO      0.938273          // Proton mass in GeV
// #define M_NEU      0.939565        // Neutron mass in GeV
// #define M_EL       0.510999/1000.0       //Electron mass in GeV
// #define M_DEU      1875.61282/1000.0     //Deuteron Mass in GeV
// #define M_HE4      3727.38272/1000.0     //Helium 4 Mass in GeV
// #define M_N        (M_PRO+M_NEU)/2.0
// #define M_PION     0.13957       //pi plus/minus mass in GeV
// #define RAD2DEG    180.0/acos(-1.0)
// #define DEG2RAD    acos(-1.0)/180.0
// #define M2G        1.0/1000.0
// #define G2M        1000.0
// #define CM2M       1.0/100.0
// #define M2CM       100.0
// #define MM2CM      1.0/10.0
// #define CM2MM      10.0

/////////////////////////Structure Definitions////////////////////////////////
typedef struct {
  unsigned raw;
  int tim;
  int edg;
  int chn;
} tdc_type;

typedef char linetype[LINLMAX];
typedef char id_name_t[11];
typedef struct {
  int pad;
  int t;
  float r;
  float phi;
  float z;
  float q;
  float qraw;
  float dist; // distance along helix from vertex
  float del; //distance away from the helix
  float res_r; //point-to-helix 'r' residual           
  float res_phi;//point-to-helix 'phi' residual       
  float res_z;//point-to-helix 'z' residual
  float res_q;//charge-to-adc-slope fit residual
  float res_qr;//charge-to-adc-slope fit residual
  int status;
} hitlist; /* all hits in RTPC are stored in this structure */

typedef struct {
  float phi;
  float z;
  float s;
  float charge;
} cylindrical; //this is the raw data type

typedef struct {
  float x;
  float y;
  float z;
  float charge;
  int t;
} cartesian; // a type to store hit info in (x,y,z,pulse_height) vectors

typedef struct {
  float sig_entr; /* sigma where track enters tracking volume */
  float sig_exit; /* sigma where track exits tracking volume */
  float smin;     /* sigma where first signal occurs on this track */
  float smax;     /* sigma where last signal occurs on this track */
  float sig_fid_entr; /* sigma where track enters sensitive volume of RTPC */
  float sig_fid_exit; /* sigma where track exits sensitive volume of RTPC */
  float p_tot;
  float p_hlx;    /* raw momentum from helix fit */
  float p_corr;   /* momentum corrected to event vertex */
  float p_x;
  float p_y;
  float p_z;
  float theta;
  float phi;
  float xdca;
  float ydca;
  float zdca;
  float sign;     /* sign of particle charge */
  float r_0;       /* fitted helix radius */
  float xv;       /* x of helix point nearest beamline */
  float yv;
  float zv;
  float thv;      /* scattering angle at point nearest beamline */
  float phv;      /* phi direction at point on helix nearest beamline */
  float dqdx;     /* measured signal per mm of track length */
  float fiddqdx;     /* measured signal per mm of length on portion of helix within sensitive volume*/
  float livedqdx; /* dqdx measured as total charge on track divided by live_length */
  float npts;    /* number of measured points used in helix fit */
  float visq;   /* visible charge on track */
  float fitqual;  /* some measure of quality of track fit */
  float edist; /* at end of track: length in tracking volume making no signal */
  float sdist; /* invisible length at beginning of track */
  int t_smin; /* altro-time of signal at beginning of track */
  int t_smax; /* altro-time of signal at end of track */
  float vtl;   /* visible track length */ 
  float fidtl; /* path length from entry to exit of sensitive volume */
  float live_length; /* path length through region instrumented by working readout pads */
  float bad; /* fraction of path subtended by bad pads */
  float chi2; /* chi2/dof of helix fit */
  float qtruncA,qtruncL,qtruncAL; // truncated track charges
  float Rxy,alpha,beta,chisq,qint; // q-slope parameters
  float sminL,smaxL; // path-length-truncated versions
  float live_lengthL,live_lengthA,live_lengthAL; // path-length-truncated versions
} trackvtype;  /* a thing to store various fitted track parameters in */

typedef struct {
  int row;
  int col;
  float phi; //in radians!
  float z; //mm
} coordinates;

extern struct {
  int tpc_hits_nb;
  int chan_nb[1000];
  int adc[1000];
  float cadc[1000];
  int tdc[1000];
  float dist[1000];
  float qres[1000];
  float qresr[1000];
  int track_nb[1000];
} tpc_hits_;
//////////////////////////Begin function prototype section/////////////////////
#ifdef __cplusplus
extern "C" int read_BOS();
#else
extern int read_BOS();
#endif

double phrng(double);
double delphrng(double);
void calcVolt(float , float , float , float);
float dca_to_helix(float,float,float,float,float,float,float,hitlist*,cylindrical*,float*);
void helix_fit(int,int,int);
int circle_int(float,float,float,float,float,float,float*,float*,float*,float*);
int inside_rtpc(float, float, float);
int inside_rtpc_cyl(cylindrical);
float track_charge(int,float*,float*,float*);
int findwall(int, int, float*, float*);
float sumtrackq(int, float*, float*, int*, int*);
int clean_hits();
int removeRes(int, int);
void readBFmap();
float bofz(float);
float bofrz(float,float);
void sig2xyz(int, float, cartesian*);
void sig2rpz(int, float, cylindrical*);
int prowcol(float, float, float*, float*);
int rowcol2pad(int,int);
int read_scale();
int read_scale_db(const int runno);
void scale_hits();
int init_paths();
void bfield(float, float, float, double*, double*, double*);
void pad2rowcol(int, int*, int*);
void z2beamxy(float , float*, float*);
float lineandhelix(float, float, float, float, float, float, float, float, float,  float);
void GetBLPara(int, int, double*, double*, double*, double*);
void init_CS();
int chain_link();
void generate_pad_locations();
void hits_to_space();
void sum_hit_charges(int*, float*);
void track_qpad(int,float,float,float,float);
int dead_pad(int);
int TPC_BOS_ReadTPCData();
void print_track(int);
int countPads(int,int);
void read_bad_pads();
int read_bad_pads_db(const int runno);
void gem_print_stats();
void rwfthc(int, float*, float*, float*, float*, float*,
            int, int*, float*, float*, float*, float*,
            float*, float*);


// BoNuS stuff (unused or replaced):
//float getdelphi(float, float, int, float);
//void setPadTimes(float, float*, int, float, float*);
//int proj_to_pads(cylindrical, cylindrical*, float*);
//void read_path_fits_file();
//void init_paths_using_magboltz();
//float getS(float, float, int);
//float getPhi(int, float, int, float);
//void transXYZ(int, float, float, float, float*, float*, float*);
//void transMOM(int, float, float, float, float*, float*, float*);
//int weightData(int);
//float dqdx_hedme(float, float, float);
//int RTPC_dqdxCut(int, float);

// EG6 stuff:
int proj_to_pads_fit_eg6(cylindrical, cylindrical*, float*);
void init_paths_using_fit_eg6();
float getdelphi_fit_eg6(float, int);
float getr_fit_eg6(float, int);
float get_TDCmax_eg6(float);
float eg6rtpc_eloss(int, float, float);
float eg6rtpc_dedx(float, float, float);
void eg6rtpc_pids(float, float, float, int*, float*);
int eg6rtpc_read_pedestal();



//////////////////////////Constant Array Definitions///////////////////////////
/* The channel mapping within the two types of connectors (even/odd): 
     This turns a pin location within a connector (the index) into an 
     altro channel number (the array element value).
             pcb_map[even_odd][conn_side][conn_col] */
static const int pcb_map[2][2][8] ={ { {7, 8,12, 3, 0,15,11, 4}, 
                                   {13, 6, 2, 9,10, 1,14, 5} }, 
                                 { {15, 0, 4,11, 8, 7, 3,12},
                                   {5,14,10, 1, 2, 9, 6,13} } };

  /* The inverse channel map within the two types of connectors (even/odd):
     This turns an altro channel number (the index) into a pad location (value)
     specified by the row/column of that pad within this connector's group of 16.
  */

static const int seq_col[2][16] = { {4, 5, 2, 3, 7, 7, 1, 0, 1, 3, 4, 6, 2, 0, 6, 5},   /*even*/
                              {1, 3, 4, 6, 2, 0, 6, 5, 4, 5, 2, 3, 7, 7, 1, 0} }; /*odd */
static const int seq_row[2][16] = { {0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0},   /*even*/
                              {0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0} }; /*odd */


/* The angular (phi) locations of the centers of the first row of pads on the
   left and right rtpc modules, respectively: */
static const float phi_start[2]= { 5.02700, 1.88542 };

/* Rows of pads may be shifted along Z... starting with bottom row on left rtpc
   (top row on right rtpc) and proceeding in increasing phi:

     1st row   no shift in z
     2nd row   shifted by +1.0 mm in z (1mm downstream)
     3rd row   no shift
     4th row   shifted by -2 mm in z (2mm upstream)
     repeat

   So the pad centers of the first pads on each row are at these positions:*/
static const float zoff[4]= { -97.50, -96.50, -97.50, -99.50};

/* parameters for drift paths from Katya*/

// parameters for time
/*
  static const float alpha_drift[8] =
                                {-1.139261e+00
                                ,1.592560e-02
                                ,2.591205e-04
                                ,3.759540e-01
                                , 1.421512e-05
                                , 1.705103e-10
                                , 9.412887e-01
                                , 1.581020e-04};

  static const float beta_drift[8] =
                                {1.963586e+03
                                ,-3.762674e+01
                                ,1.934985e-01
                                , 9.914864e+00
                                , -2.823729e-04
                                , 4.923376e-09
                                , 1.773905e+00
                                , -5.576439e-04};

  static const float kappa_drift[8] =
                              {7.079891e-01
                              ,-2.962066e-03
                              ,3.557293e-06
                              , 9.751035e-01
                              , -6.580110e-06
                              , 2.029836e-11
                              , 9.391107e-01
                              , 4.620730e-05};

// parameters for phi
  static const float delta_drift[8] = 
                              {-2.219188e+01
                              ,5.932668e-01
                              ,-4.249370e-03
                              ,1.020934e+00
                              , -1.121975e-05
                              , 5.475347e-10
                              , 1.235269e+00
                              , -1.083158e-04};

  static const float eta_drift[8] = 
                              {3.060368e+00
                              ,-8.285797e-02
                              ,5.974823e-04
                              , 1.045956e+00
                              , -1.199048e-05
                              , 5.014414e-10
                              , 1.029865e+00
                              , 4.207266e-05 };

  static const float gamma_drift[8] = 
                              {7.691682e+03
                              ,-1.622685e+02
                              ,9.020071e-01
                              , 1.437250e+00
                              , 1.320398e-05
                              , 5.734709e-10
                              , 4.999160e+00
                              , -2.045665e-03};
*/
/* parameters for offset */

/* time */
/*
static const float p_off_right[18] =
// Yohann's
	             {3.711588e-08
	             ,-4.891876e-04
	             ,2.533412e+00
	             ,1.049901e-08
	             ,-8.046949e-05
	             ,2.769193e-01
	             ,9.381976e-13
	             ,-4.256494e-09
	             ,1.514506e-06
	             ,3.286046e-12
	             , -8.390133e-05
	             , 9.676930e+02
	             , -1.487577e-16
	             , 5.127030e-09
	             , -8.995567e-02
	             , -3.366334e-16
	             , 7.244202e-09
	             , -1.656115e-02}; 
*/
// Katya's
/*			{3.713609e-08,
			-5.103477e-04,
			3.138004e+00,
			2.218389e-08,
			-2.238667e-04,
			8.353619e-01,
			-2.667617e-11,
			2.927210e-07,
			-9.101987e-04,
			1.871027e-11,
			-1.112985e-04,
			6.257220e+02,
			-2.882196e-15,
			1.477272e-08,
			-6.306664e-02,
			2.277637e-15,
			-1.018320e-08,
			8.639543e-03}; 
*/


/*phi*/
/*
static const float c_right[8] = 
// Yohann's
          {-1.269119e-04
          ,9.860067e-03
          ,-1.467569e-05
          ,9.471814e-04
          ,4.062355e-10
          ,-2.895958e-08
          ,6.764840e-01
          ,-4.485859e+01};
*/
// Katya's
 /*       {1.353956e-05,
         -1.260332e-03,
         -1.420283e-05,
         8.822876e-04,
         5.222136e-10,
         -3.603938e-08,
         1.980565e-01,
         -7.743328e+00};
*/

/*
static const float p_off_left[18] =
// Yohann's
	             {3.711588e-08
	             ,-4.891876e-04
	             ,2.533412e+00
	             ,1.049901e-08
	             ,-8.046949e-05
	             ,2.769193e-01
	             ,9.381976e-13
	             ,-4.256494e-09
	             ,1.514506e-06
	             ,3.286046e-12
	             , -8.390133e-05
	             , 9.676930e+02
	             , -1.487577e-16
	             , 5.127030e-09
	             , -8.995567e-02
	             , -3.366334e-16
	             , 7.244202e-09
	             , -1.656115e-02};
*/
// Katya's
 /*                      {3.713609e-08,
                        -5.103477e-04,
                        3.138004e+00,
                        2.218389e-08,
                        -2.238667e-04,
                        8.353619e-01,
                        -2.667617e-11,
                        2.927210e-07,
                        -9.101987e-04,
                        1.871027e-11,
                        -1.112985e-04,
                        6.257220e+02,
                        -2.882196e-15,
                        1.477272e-08,
                        -6.306664e-02,
                        2.277637e-15,
                        -1.018320e-08,
                        8.639543e-03};
*/
/*
static const float c_left[8] =
// Yohann's
          {-1.269119e-04
          ,9.860067e-03
          ,-1.467569e-05
          ,9.471814e-04
          ,4.062355e-10
          ,-2.895958e-08
          ,6.764840e-01
          ,-4.485859e+01}; 
*/
// Katya's
/*        {1.353956e-05,
         -1.260332e-03,
         -1.420283e-05,
         8.822876e-04,
         5.222136e-10,
         -3.603938e-08,
         1.980565e-01,
         -7.743328e+00};
*/
//////////////////////////////////Global Varibales/////////////////////////////
hitlist hh_hitlist[HH_MAX_NUM_HITS];/* structure of all hits in the RTPCs and their status */
hitlist hh_xtrlist[HH_MAX_NUM_XTRS];/* structure of all hits in the extra ALTRO channels */
int hh_num_hits; /* count number of hit-chains */
int hh_num_xtrs; /* count number of hits in extra altro channels */

int chain_hits[MAX_NUM_CHAINS][MAX_HITS_ON_CHAIN];
int num_chains, num_hits_this_chain[MAX_NUM_CHAINS];
int track_chain[EVT_TRKS]; /* gives the chain number associated with the indexed track number */
int tmax, tmin;
float z_exit;  //the z position of the the track exit point
float sol_current; //the current of the solenoid in Amperes

//I'm defining these here cause I'm lazy
float sVals1[NUM_S1]; //the array of the s values from the field map
float zVals1[NUM_Z1]; //the array of the z values from the field map
float int_Bs[NUM_S1][NUM_Z1]; //the array of the Br values from the field map
float int_Bz[NUM_S1][NUM_Z1]; //the array of the Bz values from the field map

int nal_samp;/* VARIABLE number corresponding to the above */
int nal_keep;
int num_bad_altro_data;
char singleChar[2]; /* temporary place to stick single characters */
float pad_dat[NAL_SAMP][NUM_PADS], xtra_dat[NAL_SAMP][NUM_XTRA];
float corr_fac[NUM_PADS];
float eg6peds[NUM_PADS];
int good_altro_data;
linetype textline;

coordinates padLocs[NUM_PADS];
float dzds[EVT_TRKS];
float track_theta, track_phi;
trackvtype trackv[EVT_TRKS];
int ntracks;
float x_0[EVT_TRKS], y_0[EVT_TRKS],r_0[EVT_TRKS], phi0[EVT_TRKS];
float x_close[EVT_TRKS], y_close[EVT_TRKS], z_close[EVT_TRKS];
float dca[EVT_TRKS];  /* distance of closest approach of track to beamline */
int   helix_error[EVT_TRKS];
float chi2[EVT_TRKS]; /* total chi**2 of track fit */

cartesian point_entry, point_exit, point_appear, point_disappear;

int num_events, totTrkd, numRawPoints, thisPadWasHit, clas_global_eid;
int nevt_toomanyhits, frac_nodrift;

float qtot_early, qtot_intime, qtot_late;
cylindrical rawCYL[NAL_SAMP][NUM_PADS]; /*holds the signal data for the first linefit
	                      a NODATA in charge indicates there is no data*/
int badPads[NAL_CHAN], num_bad_pads;
int printPads;
int fit_track_to_beamline;
int rwfopt;

float Lvdrift, Rvdrift, Lvgem, Rvgem;
float helium_fraction;
float altro_thresh, altro_offset;
int runNum;
int pad_uses[NUM_PADS]; //holds the number of times a pad was used on a track in the entire run
int writePadUses;       //should we write out the pad uses file?
/* truncated energy (charge) sums ... per track. accumulated in track_qpad */
float e_trunc_low, e_trunc_mid, e_trunc_40, e_trunc_50, e_trunc_60, e_trunc_70, e_trunc_80; 
//float bmx0,bmy0,byz0,bmdxdz,bmdydz; /* intercept and slopes of the beamline in BoNuS CS */

double bmx0, bmdxdz, bmy0, bmdydz;
float bmalpha, bmbeta, bmgamma, bmxoff, bmyoff, bmzoff;
float boalpha, bobeta, bogamma, boxoff, boyoff, bozoff;
float soalpha, sobeta, sogamma, soxoff, soyoff, sozoff;

//this array is to keep track of various errors which can occur during runtime

int errors[MAX_ERRORS];

/*
0: rwfthc() called w/ > 300 points
1: rwfthc() called w/ < 3 points
2: bfield() radial coordinate is out of range
3: bofz() axial coordinate is out of range
4: chain_link() given too many chains
5: helix_fit() called with wrong chain number
6: read_BOS() more hits than space allocated in hitlist
7: read_BOS() channel from bos bank out of range
8: read_BOS() altro time value not allowed
9: read_BOS() altro time value out of range
10: read_BOS() more extras than space allocated
11: scale_hits() finds a bad pad number
12: sum_hit_charges() finds a pad number disagreement
13: track_charge() track never intersects RTPC
14: track_charge() track starts inside RTPC but never hits a wall

*/
//these are the values to change the various magboltz parameters in an attempt
//to find the right drift electron paths.

//float dVGL, dVKL, dVGR, dVKR, delpoff[2];

//DRIFT VELOCITY CALIBRATION PARAMETERS

float deltaVGR, deltaVGL, deltaVKR, deltaVKL;
float p_path_off[2];
float delta_helium;
time_t start, end;
double elapsed;
time_t rawtime;
struct tm * timeinfo;

// NEW FOR EG6:

int RejectNoise();
int IsOnNoiseCurve2(const int tdc,const int adc);
int IsNoise(int nhit,const int tdcs[NAL_SAMP],const int adcs[NAL_SAMP]);
int IsPadNoisy(const int pad);
int IsPadInNoisyBoard(const int pad);

void CountBoardPads(int nbrdpads[200]);
int RejectBusyBoards();
int RejectBoard(const int board);
int GetBoardNeighbors(const int board,int ihits[HH_MAX_NUM_HITS]);
int ApplyHotBoardPedestal(const int board);
int BusyBoards();

int rowcol2board(const int row,const int col);
int pad2board(const int pad);

void qslope(const int tracknum,const float smin,const float smax,
            const int npt,int indices[MAX_HITS_ON_CHAIN],
            const float adcrejfrac);

float qtrunc(const int tracknum,const float smin,const float smax,
             const int npt,int indices[MAX_HITS_ON_CHAIN]);


